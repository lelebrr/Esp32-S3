#include "ai_attack_learner.h"`n#include "../modules/others/tts_advanced.h"
#include <Wire.h>
#include <DallasTemperature.h>
#include <TinyGPS++.h>
#include <WiFi.h>
#include <BLEDevice.h>
#include <SD.h>
#include <FS.h>

// External dependencies (assuming they exist in the project)
extern OneWire oneWire;
extern DallasTemperature sensors;
extern TinyGPSPlus gps;
extern bool wifiConnected;
extern bool BLEConnected;

// TensorFlow Lite model data (placeholder - would be generated by Edge Impulse)
#ifdef HAS_TFLITE
alignas(16) static const unsigned char model_data[] = {0}; // Replace with actual model
const int tensor_arena_size = 8 * 1024; // 8KB for PSRAM
uint8_t tensor_arena[tensor_arena_size];
#endif

AIAttackLearner aiLearner;

AIAttackLearner::AIAttackLearner() :
#ifdef HAS_TFLITE
    model_(nullptr),
    interpreter_(nullptr),
    input_tensor_(nullptr),
    output_tensor_(nullptr),
    tensor_arena_(tensor_arena),
#endif
    top_attacks_cache_(nullptr),
    cache_initialized_(false),
    initialized_(false),
    stealth_mode_(false),
    last_action_(ATTACK_NONE),
    last_update_(0),
    last_stealth_check_(0),
    last_backup_(0),
    voice_wake_enabled_(false),
    gesture_wake_active_(false),
    last_gesture_time_(0) {

    // Initialize Q-table with zeros
    memset(q_table_, 0, sizeof(q_table_));
    
    // Initialize hardware fingerprint
    hw_fingerprint_ = {
        .has_ble = true,
        .has_nfc = true,
        .has_wifi = true,
        .has_subghz = true,
        .has_ir = true,
        .has_gps = true,
        .esp32_variant = "ESP32-S3-N16R8",
        .firmware_version = LELE_VERSION
    };
}

AIAttackLearner::~AIAttackLearner() {
#ifdef HAS_TFLITE
    if (interpreter_) {
        delete interpreter_;
    }
#endif
}

bool AIAttackLearner::init() {
    if (initialized_) return true;

    prefs_.begin("ai_attack", false);

    // Load existing Q-table
    if (!loadModel()) {
        // Initialize with default values
        for (int s = 0; s < NUM_STATES; s++) {
            for (int a = 0; a < NUM_ACTIONS; a++) {
                q_table_[s][a] = 0.0f;
            }
        }
    }

    // Initialize TensorFlow Lite
#ifdef HAS_TFLITE
    model_ = tflite::GetModel(model_data);
    if (!model_) {
        Serial.println("[AI] Failed to load TFLite model");
        return false;
    }

    static tflite::AllOpsResolver resolver;
    interpreter_ = new tflite::MicroInterpreter(model_, resolver, tensor_arena_, tensor_arena_size);

    if (interpreter_->AllocateTensors() != kTfLiteOk) {
        Serial.println("[AI] Failed to allocate tensors");
        return false;
    }

    input_tensor_ = interpreter_->input(0);
    output_tensor_ = interpreter_->output(0);
#endif

    initialized_ = true;
    Serial.println("[AI] Attack learner initialized");
    return true;
}

ContextFeatures AIAttackLearner::gatherContext() {
    ContextFeatures ctx = {0};

    // GPS data
#ifdef HAS_GPS
    if (gps.location.isValid()) {
        ctx.gps_lat = gps.location.lat();
        ctx.gps_lon = gps.location.lng();
    }
#endif

    // Temperature
#ifdef HAS_TEMP_SENSOR
    sensors.requestTemperatures();
    ctx.temperature = sensors.getTempCByIndex(0);
#endif

    // Battery voltage
#ifdef HAS_BATTERY_ADC
    ctx.battery_voltage = analogRead(VBAT_ADC_PIN) * 3.3 / 4095.0 * 2.0; // Assuming voltage divider
#endif

    // Hardware availability
    ctx.nfc_available = true; // Assume available
    ctx.subghz_available = true;
    ctx.ble_available = BLEConnected;
    ctx.wifi_available = wifiConnected;

    // Network type (placeholder)
    ctx.network_type = 0; // WPA2 default

    return ctx;
}

int AIAttackLearner::discretizeState(const ContextFeatures& context) {
    // Simple discretization: combine features into state index
    int lat_bin = constrain((int)((context.gps_lat + 90) / 180 * 4), 0, 3);
    int lon_bin = constrain((int)((context.gps_lon + 180) / 360 * 4), 0, 3);
    int temp_bin = constrain((int)(context.temperature / 10), 0, 3);
    int batt_bin = constrain((int)(context.battery_voltage / 1.0), 0, 3);

    return lat_bin * 16 + lon_bin * 4 + temp_bin * 1 + batt_bin;
}

AttackType AIAttackLearner::epsilonGreedy(int state) {
    if (random(100) < (EPSILON * 100)) {
        return (AttackType)random(NUM_ACTIONS);
    }

    float max_q = -FLT_MAX;
    AttackType best_action = ATTACK_NONE;

    for (int a = 0; a < NUM_ACTIONS; a++) {
        if (q_table_[state][a] > max_q) {
            max_q = q_table_[state][a];
            best_action = (AttackType)a;
        }
    }

    return best_action;
}

AttackType AIAttackLearner::predictAttack(const ContextFeatures& context) {
    if (!initialized_) return ATTACK_NONE;

    if (stealth_mode_) {
        // In stealth mode, only use low-power attacks
        return ATTACK_NONE;
    }

    int state = discretizeState(context);

    // Use TFLite for prediction if model is loaded
#ifdef HAS_TFLITE
    if (interpreter_) {
        float inputs[8] = {
            context.gps_lat, context.gps_lon, context.temperature,
            context.gesture_type, context.battery_voltage,
            context.nfc_available, context.subghz_available, context.ble_available
        };

        memcpy(input_tensor_->data.f, inputs, sizeof(inputs));
        interpreter_->Invoke();

        float* output = output_tensor_->data.f;
        int predicted_action = 0;
        float max_prob = output[0];

        for (int i = 1; i < NUM_ACTIONS; i++) {
            if (output[i] > max_prob) {
                max_prob = output[i];
                predicted_action = i;
            }
        }

        last_action_ = (AttackType)predicted_action;
        return last_action_;
    }
#endif

    // Fallback to Q-Learning
    last_action_ = epsilonGreedy(state);
    return last_action_;
}

void AIAttackLearner::updateQTable(AttackType action, float reward) {
    if (!initialized_) return;

    ContextFeatures ctx = gatherContext();
    int state = discretizeState(ctx);

    float old_q = q_table_[state][action];
    float max_next_q = getMaxQValue(state);

    q_table_[state][action] = old_q + LEARNING_RATE * (reward + DISCOUNT_FACTOR * max_next_q - old_q);

    // Auto-save periodically
    if (millis() - last_update_ > 300000) { // 5 minutes
        saveModel();
        last_update_ = millis();
    }
}

float AIAttackLearner::getMaxQValue(int state) {
    float max_q = q_table_[state][0];
    for (int a = 1; a < NUM_ACTIONS; a++) {
        if (q_table_[state][a] > max_q) {
            max_q = q_table_[state][a];
        }
    }
    return max_q;
}

void AIAttackLearner::provideFeedback(bool success) {
    float reward = success ? 1.0f : -1.0f;
    updateQTable(last_action_, reward);
}

bool AIAttackLearner::downloadExploitDB() {
    if (!wifiConnected) return false;

    http_.begin("https://api.exploit-db.com/exploits?type=cve");
    http_.addHeader("User-Agent", "ESP32-AI-Learner/1.0");

    int httpCode = http_.GET();
    if (httpCode != HTTP_CODE_OK) {
        Serial.printf("[AI] ExploitDB API failed: %d\n", httpCode);
        http_.end();
        return false;
    }

    String payload = http_.getString();
    http_.end();

    // Parse JSON
    DynamicJsonDocument doc(8192);
    DeserializationError error = deserializeJson(doc, payload);

    if (error) {
        Serial.printf("[AI] JSON parse error: %s\n", error.c_str());
        return false;
    }

    // Process exploits
    File exploitsFile = SD.open("/ai/exploits_db.json", FILE_WRITE);
    if (!exploitsFile) {
        Serial.println("[AI] Failed to open exploits file");
        return false;
    }

    serializeJson(doc, exploitsFile);
    exploitsFile.close();

    Serial.printf("[AI] Downloaded %d exploits\n", doc.size());
    return true;
}

bool AIAttackLearner::downloadNIST() {
    if (!wifiConnected) return false;

    http_.begin("https://services.nvd.nist.gov/rest/json/cves/2.0");
    http_.addHeader("User-Agent", "ESP32-AI-Learner/1.0");

    int httpCode = http_.GET();
    if (httpCode != HTTP_CODE_OK) {
        Serial.printf("[AI] NIST API failed: %d\n", httpCode);
        http_.end();
        return false;
    }

    String payload = http_.getString();
    http_.end();

    // Parse and filter relevant CVEs
    DynamicJsonDocument doc(16384);
    DeserializationError error = deserializeJson(doc, payload);

    if (error) {
        Serial.printf("[AI] NIST JSON parse error: %s\n", error.c_str());
        return false;
    }

    // Filter for hardware-related CVEs
    JsonArray vulnerabilities = doc["vulnerabilities"];
    DynamicJsonDocument filtered(8192);
    JsonArray filteredArray = filtered.to<JsonArray>();

    for (JsonObject vuln : vulnerabilities) {
        JsonObject cve = vuln["cve"];
        String cveId = cve["id"];

        // Check if relevant to our hardware
        if (cveId.indexOf("BLE") != -1 || cveId.indexOf("NFC") != -1 ||
            cveId.indexOf("WiFi") != -1 || cveId.indexOf("RF") != -1) {
            filteredArray.add(vuln);
        }
    }

    // Save filtered CVEs
    File nistFile = SD.open("/ai/nist_cves.json", FILE_WRITE);
    if (!nistFile) {
        Serial.println("[AI] Failed to open NIST file");
        return false;
    }

    serializeJson(filtered, nistFile);
    nistFile.close();

    Serial.printf("[AI] Downloaded %d relevant CVEs\n", filteredArray.size());
    return true;
}

bool AIAttackLearner::updateAttacksFromAPI() {
    if (!wifiConnected) {
        Serial.println("[AI] No WiFi connection for API update");
        return false;
    }

    bool success = false;
    success |= downloadExploitDB();
    success |= downloadNIST();

    if (success) {
        saveModel(); // Save updated model
        Serial.println("[AI] Attack database updated from APIs");
    }

    return success;
}

bool AIAttackLearner::growBruteForceList() {
    if (!wifiConnected && !SD.exists("/brute_force/cache.json")) {
        Serial.println("[AI] No WiFi and no cache for brute force update");
        return false;
    }

    bool success = false;

    // Create directories
    if (!SD.exists("/brute_force")) {
        SD.mkdir("/brute_force");
    }

    // Update from Brazilian sources
    if (wifiConnected) {
        FastLED.showColor(CRGB::Blue); // Blue = updating

        // CVE Brasil (gov.br)
        http_.begin("https://www.gov.br/anpd/pt-br/acesso-a-informacao/vulnerabilidades");
        http_.addHeader("User-Agent", "ESP32-BruteForce/1.0");

        int httpCode = http_.GET();
        if (httpCode == HTTP_CODE_OK) {
            String payload = http_.getString();
            http_.end();

            // Parse for brute force codes
            extractBruteKeywords(payload);
            success = true;
        } else {
            http_.end();
            Serial.printf("[AI] CVE Brasil failed: %d\n", httpCode);
        }

        // Exploit-DB with BR filter
        http_.begin("https://api.exploit-db.com/exploits?type=cve&country=br");
        http_.addHeader("User-Agent", "ESP32-BruteForce/1.0");

        httpCode = http_.GET();
        if (httpCode == HTTP_CODE_OK) {
            String payload = http_.getString();
            http_.end();

            // Parse for Brazilian codes
            extractBrazilianCodes(payload);
            success = true;
        } else {
            http_.end();
            Serial.printf("[AI] ExploitDB BR failed: %d\n", httpCode);
        }

        // Reclame Aqui scraping (light scraping)
        http_.begin("https://www.reclameaqui.com.br/busca?q=senha%20padr%C3%A3o");
        http_.addHeader("User-Agent", "ESP32-BruteForce/1.0");

        httpCode = http_.GET();
        if (httpCode == HTTP_CODE_OK) {
            String html = http_.getString();
            http_.end();

            // Parse HTML for PIN codes
            parseHtmlForPins(html);
            success = true;
        } else {
            http_.end();
            Serial.printf("[AI] Reclame Aqui failed: %d\n", httpCode);
        }

    } else {
        // Offline mode: load cache and generate variants
        loadBruteForceCache();
        generateVariants();
        success = true;
    }

    // Update Q-table with successful codes
    if (success) {
        // Learn from successful codes (placeholder - would be implemented based on attack results)
        updateBruteForceQTable();

        FastLED.showColor(CRGB::Green); // Green = success
        _tone(1000, 100);
    }

    return success;
}

bool AIAttackLearner::validateExploit(const JsonObject& exploit) {
    // Check for required fields and validate checksum
    if (!exploit.containsKey("code") || !exploit.containsKey("checksum")) {
        return false;
    }

    String code = exploit["code"];
    String expectedChecksum = exploit["checksum"];

    // Compute SHA256
    sha256_.reset();
    sha256_.update((const uint8_t*)code.c_str(), code.length());
    uint8_t hash[32];
    sha256_.finalize(hash, sizeof(hash));

    char computedChecksum[65];
    for (int i = 0; i < 32; i++) {
        sprintf(computedChecksum + i*2, "%02x", hash[i]);
    }

    return strcmp(computedChecksum, expectedChecksum.c_str()) == 0;
}

bool AIAttackLearner::compileExploit(const String& code) {
    // Save exploit code to SD for OTA compilation
    String filename = "/ai/exploits/attack_" + String(millis()) + ".cpp";
    File exploitFile = SD.open(filename, FILE_WRITE);

    if (!exploitFile) {
        Serial.println("[AI] Failed to save exploit code");
        return false;
    }

    exploitFile.print(code);
    exploitFile.close();

    // In a real implementation, this would trigger OTA compilation
    // For now, just log
    Serial.printf("[AI] Exploit saved to %s\n", filename.c_str());
    return true;
}

bool AIAttackLearner::saveModel() {
    if (!SD.exists("/ai")) {
        SD.mkdir("/ai");
    }

    File modelFile = SD.open("/ai/q_table.dat", FILE_WRITE);
    if (!modelFile) {
        Serial.println("[AI] Failed to save Q-table");
        return false;
    }

    modelFile.write((uint8_t*)q_table_, sizeof(q_table_));
    modelFile.close();

    // Save preferences
    prefs_.putBytes("q_table", q_table_, sizeof(q_table_));

    Serial.println("[AI] Model saved to SD and NVS");
    return true;
}

bool AIAttackLearner::loadModel() {
    // Try loading from SD first
    if (SD.exists("/ai/q_table.dat")) {
        File modelFile = SD.open("/ai/q_table.dat", FILE_READ);
        if (modelFile) {
            modelFile.read((uint8_t*)q_table_, sizeof(q_table_));
            modelFile.close();
            Serial.println("[AI] Model loaded from SD");
            return true;
        }
    }

    // Fallback to NVS
    size_t len = prefs_.getBytesLength("q_table");
    if (len == sizeof(q_table_)) {
        prefs_.getBytes("q_table", q_table_, sizeof(q_table_));
        Serial.println("[AI] Model loaded from NVS");
        return true;
    }

    return false;
}

void AIAttackLearner::backupModel() {
    String backupName = "/ai/backup_" + String(millis()) + ".dat";
    File backupFile = SD.open(backupName, FILE_WRITE);

    if (backupFile) {
        backupFile.write((uint8_t*)q_table_, sizeof(q_table_));
        backupFile.close();
        Serial.printf("[AI] Model backed up to %s\n", backupName.c_str());
    }
}

void AIAttackLearner::enterStealthMode() {
    stealth_mode_ = true;
    Serial.println("[AI] Entering stealth mode");

    // Disable high-power modules
    // Implementation depends on existing power management
    updateStealthStatus();
}

void AIAttackLearner::exitStealthMode() {
    stealth_mode_ = false;
    Serial.println("[AI] Exiting stealth mode");
    updateStealthStatus();
}

void AIAttackLearner::updateStealthStatus() {
    // Adjust power modes based on stealth status
    // This would integrate with existing power management
}

String AIAttackLearner::getHardwareFingerprint() {
    // Generate unique hardware ID for API requests
    uint32_t chipId = ESP.getEfuseMac();
    char fingerprint[17];
    sprintf(fingerprint, "%08X", chipId);
    return String(fingerprint);
}

// Brute force helper functions
void AIAttackLearner::extractBruteKeywords(const String& payload) {
    std::vector<String> codes;

    // Add common Brazilian codes
    codes.push_back("1234");
    codes.push_back("4321");
    codes.push_back("0000");
    codes.push_back("1999");
    codes.push_back("2580");
    codes.push_back("1111");
    codes.push_back("9999");
    codes.push_back("3333");
    codes.push_back("5555");
    codes.push_back("7777");

    // Extract patterns from payload (simplified)
    int pos = 0;
    while ((pos = payload.indexOf("senha", pos)) != -1) {
        int start = payload.lastIndexOf("\"", pos);
        int end = payload.indexOf("\"", pos);
        if (start != -1 && end != -1 && end > start) {
            String code = payload.substring(start + 1, end);
            if (code.length() >= 4 && code.length() <= 8 && code.toInt() > 0) {
                codes.push_back(code);
            }
        }
        pos += 5;
    }

    saveBruteForceList("/brute_force/cve_br.json", codes);
}

void AIAttackLearner::extractBrazilianCodes(const String& payload) {
    std::vector<String> codes;

    // Parse JSON for Brazilian-specific codes
    DynamicJsonDocument doc(8192);
    DeserializationError error = deserializeJson(doc, payload);

    if (!error) {
        JsonArray exploits = doc.as<JsonArray>();
        for (JsonObject exploit : exploits) {
            String description = exploit["description"];
            if (description.indexOf("Brasil") != -1 || description.indexOf("Brazil") != -1 ||
                description.indexOf("SÃ£o Paulo") != -1 || description.indexOf("Rio") != -1) {

                // Extract codes from description
                int pos = 0;
                while ((pos = description.indexOf("PIN", pos)) != -1) {
                    int start = description.indexOf("\"", pos);
                    int end = description.indexOf("\"", start + 1);
                    if (start != -1 && end != -1) {
                        String code = description.substring(start + 1, end);
                        if (code.length() >= 4 && code.length() <= 8) {
                            codes.push_back(code);
                        }
                    }
                    pos += 3;
                }
            }
        }
    }

    saveBruteForceList("/brute_force/exploitdb_br.json", codes);
}

void AIAttackLearner::parseHtmlForPins(const String& html) {
    std::vector<String> codes;

    // Simple HTML parsing for PIN codes
    int pos = 0;
    while ((pos = html.indexOf("senha", pos)) != -1) {
        int start = html.indexOf(">", pos);
        int end = html.indexOf("<", start);
        if (start != -1 && end != -1 && end > start) {
            String content = html.substring(start + 1, end);
            content.trim();

            // Check if it's a numeric code
            if (content.length() >= 4 && content.length() <= 8) {
                bool isNumeric = true;
                for (char c : content) {
                    if (!isdigit(c)) {
                        isNumeric = false;
                        break;
                    }
                }
                if (isNumeric) {
                    codes.push_back(content);
                }
            }
        }
        pos += 5;
    }

    saveBruteForceList("/brute_force/reclame_aqui.json", codes);
}

void AIAttackLearner::loadBruteForceCache() {
    // Load cached lists
    std::vector<String> allCodes;

    auto addCodes = [&](const String& filename) {
        auto codes = loadBruteForceList(filename);
        allCodes.insert(allCodes.end(), codes.begin(), codes.end());
    };

    addCodes("/brute_force/cve_br.json");
    addCodes("/brute_force/exploitdb_br.json");
    addCodes("/brute_force/reclame_aqui.json");

    // Save combined cache
    saveBruteForceList("/brute_force/cache.json", allCodes);
}

void AIAttackLearner::generateVariants() {
    auto codes = loadBruteForceList("/brute_force/cache.json");
    std::vector<String> variants;

    for (const String& code : codes) {
        variants.push_back(code);

        // Generate simple variants
        if (code.length() == 4) {
            variants.push_back(code + "0");
            variants.push_back(code + "1");
            variants.push_back("0" + code);
            variants.push_back("1" + code);
        }

        // Reverse
        String reversed = code;
        std::reverse(reversed.begin(), reversed.end());
        variants.push_back(reversed);
    }

    saveBruteForceList("/brute_force/variants.json", variants);
}

void AIAttackLearner::updateBruteForceQTable() {
    // Update Q-table with successful brute force codes
    // This would be called when a code succeeds
    // For now, boost common codes

    ContextFeatures ctx = gatherContext();
    int state = discretizeState(ctx);

    // Boost Q-values for brute force attacks in Brazilian context
    if (ctx.gps_lat >= -33.75 && ctx.gps_lat <= 5.27 && // Brazil latitude range
        ctx.gps_lon >= -73.98 && ctx.gps_lon <= -34.79) { // Brazil longitude range
        q_table_[state][ATTACK_FAULT_INJECT] += 0.5f; // NFC brute force
        q_table_[state][ATTACK_CC1101_REPLAY] += 0.3f; // SubGHz brute force
    }
}

void AIAttackLearner::saveBruteForceList(const String& filename, const std::vector<String>& codes) {
    DynamicJsonDocument doc(16384);
    JsonArray array = doc.to<JsonArray>();

    for (const String& code : codes) {
        array.add(code);
    }

    File file = SD.open(filename, FILE_WRITE);
    if (file) {
        serializeJson(doc, file);
        file.close();
        Serial.printf("[AI] Saved %d codes to %s\n", codes.size(), filename.c_str());
    }
}

std::vector<String> AIAttackLearner::loadBruteForceList(const String& filename) {
    std::vector<String> codes;

    if (!SD.exists(filename)) {
        return codes;
    }

    File file = SD.open(filename, FILE_READ);
    if (!file) {
        return codes;
    }

    DynamicJsonDocument doc(16384);
    DeserializationError error = deserializeJson(doc, file);
    file.close();

    if (error) {
        Serial.printf("[AI] Failed to parse %s: %s\n", filename.c_str(), error.c_str());
        return codes;
    }

    JsonArray array = doc.as<JsonArray>();
    for (JsonVariant v : array) {
        codes.push_back(v.as<String>());
    }

    return codes;
}
`n#include "../modules/others/audio.h"`n#include "../modules/others/tts_constants.h"`n`n// Execute attack with voice feedback`nvoid AIAttackLearner::execute_attack_with_voice(int attack_type) {`n    // Voice messages for different attack types`n    switch (attack_type) {`n        case ATTACK_DEAUTH:`n            speak_from_progmem(MSG_DETECT_VIVO_FIBRA);`n            break;`n        case ATTACK_FAULT_INJECT:`n            speak_from_progmem(MSG_DETECT_VULNERABILITY);`n            break;`n        case ATTACK_REPLAY:`n            speak_from_progmem(MSG_STARTING_ATTACK);`n            break;`n        case ATTACK_EVIL_TWIN:`n            speak_from_progmem(MSG_DETECT_GVT_WPS);`n            break;`n        case ATTACK_NFC_SPOOF:`n            speak_from_progmem(MSG_WAITING_TARGET);`n            break;`n        default:`n            speak_from_progmem(MSG_SYSTEM_READY);`n            break;`n    }`n    `n    // Small delay for voice to complete`n    delay(500);`n    `n    // Execute the actual attack`n    AttackType attack = (AttackType)attack_type;`n    // Call existing attack execution logic here`n    // (would integrate with existing attack modules)`n    `n    // Provide feedback based on success (placeholder)`n    bool success = (random(100) > 30); // 70% success rate for demo`n    if (success) {`n        speak_from_progmem(MSG_ATTACK_SUCCESS);`n        provideFeedback(true);`n    } else {`n        speak_from_progmem(MSG_ATTACK_FAILED);`n        provideFeedback(false);`n    }`n}


